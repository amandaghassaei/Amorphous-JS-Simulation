<html>
<head>
    <title>Amorphous Computing</title>
    <link rel="stylesheet" type="text/css" href="css/amorphous.css">
    <link rel="stylesheet" type="text/css" href="dependencies/jquery-ui.min.css">
    <script type="text/javascript" src="dependencies/raphael-min.js"></script>
    <script type="text/javascript" src="dependencies/jquery-1.11.1.min.js"></script>
    <script type="text/javascript" src="dependencies/jquery-ui.min.js"></script>
    <script type="text/javascript" src="js/agent.js"></script>
    <script type="text/javascript" src="js/node.js"></script>
    <script type="text/javascript" src="js/main.js"></script>
    <script type="text/javascript" src="js/uiControls.js"></script>
</head>
<body>
<div id="mainWrapper">
    <div><p>My final project proposal this week is less of a project and more of a direction that I want to head toward.  I'm not exactly sure what the implementation will look like (and even if I did, I think that would evolve a lot over the course of the next few months), so for this week I'm presenting some initial ideas and simulations of an concept I'd like to explore - <a href="http://en.wikipedia.org/wiki/Amorphous_computing">amorphous computing</a>.</p><p>Amorphous computing is a type of computational system comprised of many small, simple agents that can pass information to their immediate neighbors to produce global, emergent behavior.  Some characteristics/necessities of amorphous systems include:</p><p><strong>Local Interactions / Emergent behaviors</strong> - each agent in an amorphous network can only communicate with its nearby neighbors.  The challenge of amorphous computing is to create meaningful emergent behavior from these local interactions.</p><p><strong>Asynchronous</strong> - there is no global clock that syncs up the the agents in the amorphous network.  This limits the assumptions you can make about the state of an agent at a given time</p><p><strong>Global cooperation corrects errors in an individual</strong> - each agent in an amorphous system may have some error in its measurements, locomotion, or other functions.  These errors should begin to vanish as you "zoom out" and observe the global behavior of the group.  The presence of neighbors may also help an individual perform a task with lower error.</p><p><strong>Self healing/error correcting/fault tolerance</strong> - Some agents in the amorphous system may fail completely and the system needs to be able to respond and adapt to these changes.  The system should also be robust enough to work across various spatial topologies.</p><p>The thing that interests me the most about amorphous systems are their biological implications. Multicellular communication can be modeled as a type of amorphous system, so behaviors we observe in artificial amorphous networks may give us insights into naturally occurring phenomena.  In fact, many tactics that computer scientists use to control amorphous systems are heavily inspired by biological processes: <a href="http://en.wikipedia.org/wiki/Morphogen">morphogen gradients</a>, neighborhood query, local inhibition, local monitoring, <a href="http://en.wikipedia.org/wiki/Cellular_differentiation">agent differentiation,</a> agent to agent contact (<a href="http://www.eecs.harvard.edu/ssr/papers/saso/saso-tutorial-part1.pdf">source</a>).  <a href="http://groups.csail.mit.edu/mac/projects/amorphous/Progmat/thesis/activecells.html">This</a> paper by Radika Nagpal (with some figures from Odell, Oster, Alberch, and Burnside) demonstrates an amorphous mechanism for spatial cell arrangement and differentiation in the earliest stages of embryonic development, triggered by chemical gradients across a previously disordered mass of cells.</p><p><strong>Some other interesting examples I've found include:</strong></p><p>Bill Butera talks about the concept of a "Paintable Computer" in this <a href="http://cba.mit.edu/docs/theses/02.02.butera.pdf">thesis</a>. He explains it best: "computation as a tangible, fluidly dispersible additive to ordinary objects. Want a surface to be smart? Add a layer of computing. Want it to be smarter? Add a second coat. Has the
computing lost its luster? Get out the belt sander."</p><p><a href="https://www.youtube.com/watch?v=JmyTJSYw77g">Kilobots</a> are a very low cost (~$14 bucks per bot) platform for experimenting with swarm robotics.  The bots can be programmed, charged, and activated in parallel, and they use a low cost IR technique for communication.  <a href="http://www.eecs.harvard.edu/ssr/papers/icra12-rubenstein.pdf">This</a> paper gives a nice introduction to the technology and ideas behind their design, more information (schematics, code, programming GUIs) can be found <a href="https://www.kilobotics.com/">here</a>.</p><p><strong>The Simulation:</strong></p><p>To start exploring this concept, I designed an amorphous simulation app in JavaScript.  One of my goals for this class is to get more experience using JavaScript as a language for script-based, parametric CAD and modeling.  I've done a lot of this type of thing with Processing, and have dabbled in a few other languages (Grasshopper/Python, OpenFrameworks, Objective C/iOS) to do 2D and 3D graphics, but I want to start using JavaScript so that my code can be easily accessed through the web.  In my past life I was a content creator/developer at <a href="http://www.instructables.com/index">Instructables</a>, and one thing I noticed there was that the act of downloading code and dependencies creates a huge (probably mostly mental) obstacle for people  If you want to engage your audience with a piece of code, you have to make it incredibly easy and accessible.  I have come to the conclusion that JavaScript is the answer to this problem (for some things, there are obviously speed/memory limitations in the client side browser).</p><p>There are a few JavaScript libraries that make drawing in 2D and 3D on the <a href="http://www.w3schools.com/tags/ref_canvas.asp">canvas</a> and exporting various file formats (svg, pdf, png, stl) much easier.  Some that I've looked at include <a href="http://paperjs.org/">Paper.js</a>, <a href="http://www.createjs.com/#!/EaselJS">Easel.js</a>, <a href="http://raphaeljs.com/">Raphael.js</a>, <a href="http://kineticjs.com/">Kinetic.js</a> for 2D and <a href="http://threejs.org/">Three.js</a>/<a href="https://github.com/envisprecisely/THREE2STL">Three2STL.js</a> for 3D.  Though I'm pretty comfortable with JavaScript, I've mostly been working with more traditional UI elements (buttons, images, menus), so a lot this stuff is new for me.  This week I'm using Raphael.js, but I'd like to explore the other libraries in future weeks (I picked Raphael for now because the <a href="http://raphaeljs.com/reference.html">API</a> is relatively small and well documented).  I'm also using <a href="http://jquery.com/">JQuery</a> for interactions with elements on the page and some helper functions, and <a href="http://jqueryui.com/">JQueryUI</a> for some custom UI elements (sliders, etc).</p></div>
    <div id="svgContainer"></div>
    <div id="uiControls">
        <div class="uiControlsSub">
            <div>Number of Agents:</div>
            <div id="numAgents" class="slider"></div>
            <div>Communication Radius:</div>
            <div id="commRadius" class="slider"></div>
        </div>
        <div class="uiControlsSub">
            <div>Animation Speed:</div>
            <div id="animationSpeed" class="slider"></div>
            <div>Transmission Rate:</div>
            <div id="transmissionSpeed" class="slider"></div>
        </div>
    </div>
    <div><p>The app above demonstrates the perpetuation of a continuous line between end nodes, that does its best to maintain the shortest path between the nodes (measured by the number of agents in the path, not necessarily absolute distance). You can remove agents by clicking them, you can also click and drag the end nodes to move them - the simulation should correct for these changes. The rules for this app somewhat based off <a href="http://groups.csail.mit.edu/mac/projects/amorphous/Robust/laurenc/amorphous/">Robust Methods of Amorphous Self-Repair</a> by Lauren Clement and Radhika Nagpal, though I tried to change things a bit.  In my simulation the line between the end nodes is incrementally repaired when it breaks, eventually landing on the solution that minimizes hop count.</p><p>A few definitions from <a href="https://github.com/amandaghassaei/Amorphous-JS-Simulation">my code</a>:</p><p><strong>Agent</strong> - each circle in this simulation is an agent.  Agents have a unique id number (created from a random number generator) and have the ability to communicate with their nearby neighbors.  Agents store a few variables - state, hopCount, and successorId (defined below).</p><p><strong>Nodes</strong> - Nodes are a special type of agent.  Two nodes are included in the simulation, between which a line is drawn and maintained.  They are called "node1" and "node2".</p><p><strong>State</strong> - state is a boolean variable used to tell whether an agent is part of the line connecting the two end nodes.  Agents with state = true are drawn in red.</p><p><strong>HopCount</strong> - <a href="http://en.wikipedia.org/wiki/Hop_%28networking%29">hop</a> is a term from computer networking that refers to a node in a path that data is transmitted across.  Each time a message is passed from agent to agent, a hop count incremented by one stored in the receiving agent.  This sets us a gradient of hop count, radiating out from the origin of the message (hopCount = 0).  You can see an agent's hop count by hovering over it.</p><p><strong>SuccessorId</strong> - each agent stores the id number of its successor - the agent within communications range with the lowest hop number (there may be several, but each agent may only store 1, whichever communicates with the agent first).  This has the effect of saving a gradient across the system, where each agent is pointing in the steepest direction.</p><p><strong>CommRad</strong> - commRad (communication radius) describes the maximum radius that messages from an agent can travel.  The size of the commRad dictates how many neighbor agents a given agent can talk to. Dragging the "Communication Radius" slider shows an animation of what that asynchronous communication between agents might look like and gives you an idea of which neighbors are in range.</p><p><strong>Some assumptions/properties of my simulation:</strong><br>- the time for a message to
propagate through space is negligible compared to the time it takes for a
 message to pass from agent to agent.  This may or may not make sense depending on the type of system you are modeling (for wireless communication between electronics, this makes sense).</p><p>- agent.state expires after a certain amount of time.  This ensures that partial paths leftover by dead agents are removed in a timely manner.  Maybe there's a more elegant way of achieving this effect.</p><p>-agents do not move. For the simplicity's sake (and to avoid crashing the browser) the position of the agents is static.   There wasn't a great way for me to calculate the neighbor array in my simulation without doing a brute force check for the distance to every other agent in the system, so I didn't want to set my simulation up in a way where this would need to be recalculated continuously.  In a real, physical amorphous system this wouldn't be an obstacle because the communication radius would take care of it for me.  This is definitely a direction I'm interested in explore more.</p><p><strong>Some things I've learned this week:</strong></p><p><strong>Sufficient communication radius</strong> - is it extremely important that agents are able to communicate across a radius large enough to reach at least 4 or 5 other agents.  For sparse networks this becomes especially important.  It was surprising to see how often my random spatial distribution of agents left some agents unreachable or created very awkward gradients around sparser regions.</p><p><strong>Conclusions:</strong></p><p>I still have a few weeks before we get to the bulk of the electronics/networking section of the class, so I'm going to take this time to think about the specifics of how to physically implement some of these ideas.  I'm hoping that the topics covered in this class and the "informal robotics" class I'm listening to this semester might help guide the direction of this project.  I'd also like to expand on my simulation to quickly iterate on new ideas.</p></div>
</div>

</body>
</html>